# assembly-lab-one
A project using assembly language.


This program adds 3 byte signed integers. The  three bytes are stored in code memory using DB assembler. The answer is stored in three data memory, 40H, 41H, and 42H. The answer is also displayed on the ports (P0, P1, and P3). The least significant byte is stored in P0. P3 will display a 1 if an overflow happens, if not it stays empty. This is the first part of the lab, where all code is in one main program. 
    My main program starts in location 30H. I placed #100H and #105H into DPTR. The two three byte integers I used were: 9AH, 7FH, 89H for the first and 48H, BCH, 34H for my second integer. For 9AH I stored it in the accumulator (register A). Then I took 48H, my first byte from the second integer and placed it in register B. I then added B to my accumulator. I took my A and stored it in location 40H and also in P0.  
I needed to put my DB before I continued, so I put the beginning location for my integers. For my first integer I wrote down 100H, because 9AH, 7FH,and 89H would be in location 100H, 101H, and 102H in that order. Then for my second integer, they would be stored in location beginning in 105H so I wrote ORG 105H. 48H, BCH, 34H would be stored in 105H, 106H, and 107H in that order. After that I put an END just so I could test out my program with the first byte of my two integers to see if they would add up to the right number. 
The first step was to click on “Rebuild all target files” in the Project tab. After I saw that there were no errors or warnings, I clicked on debug and started “Debug session.” I opened port 0 from Peripherals , since that is the only one I’m working on first, and I also opened Memory Window to see the values I stored in there. I hit run, and the port 0 changed to E2 (11100010) or 226 in decimal. 9A is 154 in decimal and 48 is 72 in decimal and if you add these it would give you 226.
Meanwhile in the memory window I searched for location 100H and saw the following numbers: 9A 7F 89 00 00 48 BC 34, which are the bytes for my two integers. In location 105H the numbers: 48 BC 34.
I repeated these steps for the remaining bytes of my integers and confirmed their addition by looking at the ports (P0 P1 P2) and also by looking at the location where the answers are also located. Now, for the overflow flag I did JC (jump if carry = 1) I put a 1 in the accumulator, then stored A in location 43H, and also in P3 to check when there is overflow In the end, with my integres P3 did display a 1.  When you add 7FH and BCH it results in overflow. In the end I just opened all ports together to see the final result, by putting the ports next to each other I got the result of the two, 24 bit, integers. 
